# 深入理解Java虚拟机

---

## 第2章 Java内存区域与溢出异常

---

### 2.1 概述

### 2.2 运行时数据区域

Java虚拟机在执行Java程序时会将其管理的内存划分为若干个不同的数据区域，如下图所示

![](https://zixianghu-images.oss-cn-chengdu.aliyuncs.com/%E7%AC%94%E8%AE%B0%E6%8F%92%E5%9B%BE/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA.png)

#### 2.2.1 程序计数器

占有很小的内存区域，每个**线程所特有**，相当于当前**线程所执行的字节码的行号指示器**，字节码解释器就是通过改变程序计数器来选取下一条执行的字节码

如果线程正在执行一个Java方法，这个计数器记录的是正在执行的虚拟机**字节码指令的地址**；如果正在执行本地方法，则计数器为空

该区域是**唯一一个没有OOM的区域**

#### 2.2.2 Java虚拟机栈

**每个线程所特有**，生命周期与线程相同。**虚拟机栈是Java方法执行的线程内存模型**：每个方法被执行的时候，Java虚拟机栈都会创建一个同步**栈帧**（存储**局部变量表**、**操作数栈、动态链接和方法出口**等）。**一个方法被调用到执行完毕对应了一个栈帧在虚拟机栈中从入栈到出栈的过程**

局部变量表存放了编译期可知的**基本类型**、对象引用（**reference类型**，它不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或者其他与此相关的位置）和**returnAdress类型**（指向一条字节码指令的地址）

这些数据类型在局部变量表中以局部变量<b>槽(Slot)</b>来表示，其中64位的long和double占用两个Slot，其余的变量占用一个Slot。**局部变量表所需的内存在编译期间便完成了分配。当进入一个方法时，这个方法所需要在栈帧中分配多大的局部变量空间是完全确定的**

1. 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常
2. 如果Java虚拟机栈容量可以动态扩容，当栈扩展无法申请到足够的内存时会抛出OOM异常

值得注意的是，**HotSpot虚拟机的栈容量是不可以动态扩容的，只要线程申请到了占空间就不会抛出OOM异常；如果申请失败，仍然会抛出OOM异常**

#### 2.23 本地方法栈

与虚拟机栈的作用相似，只是其为本地方法服务。在HotSpot虚拟机中，本地方法栈和虚拟机栈实现合二为一

#### 2.2.4 Java堆

堆内存被**所有线程共享**，是虚拟机所管理的最大的一块内存区域。**此内存的唯一目的就是存放对象实例，Java中所有对象实例都在这里分配内存**

从分配内存角度来看，所有线程共享的Java堆可以划分出多个线程私有的分配缓冲区（**TLAB**，Thread Local Allocation Buffer）来提升对象分配的效率，但是无论怎么划分，堆内存中存储的只能是对象的实例

Java堆是垃圾回收器主要活动的区域，其可以物理上不连续，但是其逻辑上应该被视为连续的

Java虚拟机可以通过参数改变堆的大小，当堆中没有内存完成对象实例的分配时，将抛出OOM异常

- -Xmx：堆最大值设定，例如_Xmx20m
- -Xms：堆最小值设定，例如_Xms20m

#### 2.2.5 方法区

方法区被**所有线程所共享**，用于存储被虚拟机加载的**类型信息、常量、静态变量、访问修饰符、即时编译器编译后的代码缓存**等数据

方法区是堆区的一个逻辑部分，但是它也叫**非堆**，目的就是为了与堆区分开

值得注意的是永久代和方法区并不一样，JDK8已经完全废弃了永久代的概念。**JDK7的HotSpot，把原来放在永久代的的字符串常量池、静态变量等移出，到JDK8，完全废弃了永久代的概念，改用与J9、JRockit一样在本地内存中实现的元空间来代替，把JDK7永久代中剩余的内容（比如类型信息）全部移到元空间**

方法区中可以不是先垃圾回收，但并不代表这个区域的数据可以永久存在。**这个区域的回收主要是针对常量池的回收和对类型的卸载**，这种回收一般难以令人满意，尤其是类型卸载的条件相当苛刻（见3.2.5）

如果方法区无法满足新的内存分配将抛出OOM异常

#### 2.2.6 运行时常量池

运行时常量池是方法区的一部分，Class文件中的常量池表用于存放编译期生成的各种[字面量和符号引用](#字面量和符号引用)，这部分内容在类加载后存放到方法区的运行时常量池中

#### 2.2.7 直接内存

直接内存不是虚拟机运行时数据区的一部分，但是其仍然可能导致OOM异常

在JDK1.4中新加入的NIO类，引入一种基于通道与缓存区的I/O方式，它可以**通过Native函数直接分配堆外内存，然后通过堆中的DirectByteBuffer对象作为这块内存的引用进行操作，在一些场景中能避免Java堆和Native堆来回复制数据导致性能下降的问题**

### 2.3 HotSpot虚拟机对象探秘

#### 2.3.1 对象的创建

1. Java虚拟机遇到字节码new指令时，首先检查这个指令的参数能否在**常量池中定位到一个类的[符号引用](#字面量和符号引用)**，并检查这个符号代表的类是否被加载、解析和初始化过。如果没有则执行相应的类加载过程（第7章）

2. 类加载完成后，虚拟机将为新生对象分配内存，对象所需内存在类加载完成后便可以完全确定。分配内存的方式有**指针碰撞和空闲列表**两种

* 指针碰撞：如果Java堆中内存是绝对规整的，使用的内存在一边，空闲的内存在另一边，中间放着一个指针作为指示器，当分配内存时仅需将指针向空闲那边挪动即可。但是，如果内存并不规整，这种方法就不管用
* 空闲列表：虚拟机维护一个列表，记录那块内存是可用的，那块是不可用的，在分配内存时找到一个足够大的空间分配给对象实例并更新列表

选择那种分配方式取决于堆是否规整，当**使用Serial、Parnew（使用标记复制算法）等带压缩整理过程的收集器时，系统采用指针碰撞；使用CMS（标记清除）时理论上只能使用空闲列表来分配内存**

同时为了解决高并发下分配内存的不安全问题，可以使用CAS配上失败重试保存更新的原子性或者使用**TLAB**（本地线程分配缓存），预先将线程分配动作划分到不同空间中进行，那个线程分配内存就在自己的本地缓存中分配，只有本地缓存用完之后才需要锁定在堆中分配

3. 内存分配完之后，虚拟机需要将分配到的内存空间初始化（不包括对象头）都初始化为零值，这步操作**保证了对象实例字段在Java代码中不赋值即可使用**

4. 接下来才是对**对象头初始化**，比如设置这个对象是那个类的实例、哈希码、对象的GC分代年龄等

5. 当1~4步做完之后，从Java程序的角度来看，对象的创建才刚刚开始——构造函数，即Class文件中的**init()方法**，此时所有字段都是默认的零值，对象需要按照程序员意图进行初始化

#### 2.3.2 对象的内存布局

对象在堆内存中的布局可以划分为三部分：**对象头、实例数据、对齐填充**

**①<span id="对象头">对象头</span>**

对象头包括两类信息：第一类是用于存储自身运行时数据，如哈希码、 GC分代年龄、锁状态标志、线程持有锁、偏向锁ID等；第二类信息是类型指针，即对象指向它的类型元数据的指针，Java虚拟机通过这个指针来确定该对象是哪个类的实例（并不是所有虚拟机都必须在对象数据上保留类型指针，也就是查找对象的元数据信息并不一定要经过对象本身，如果是数组对象，对象头还要标记数组的长度）

**②实例数据**

实例数据部分存储了对象的真正有效信息，即程序中所定义的各种类型的字段（包括从父类继承下来的）。HotSpot虚拟机默认的存放数据是相同宽度的字段被分配一起存放，满足这个条件的前提，父类中的变量会出现在子类之前

**③对齐填充**

对齐填充仅仅起着占位符的作用，由于HotSpot虚拟机的自动内存管理系统要求对象起始地址必须是8字节，也就是任何对象的大小都必须是8字节的整数倍，对象头已经被设计为了8字节的倍数，如果实例数据不是8字节的倍数可以通过该部分进行填充

#### 2.3.3 对象的访问定位

**Java程序通过栈上的reference数据类型操作堆上的具体对象**

主流的对象访问分为两种

1. 使用句柄访问。Java堆中分出一块内存作为句柄池，reference中存储的是对象的句柄地址，句柄中包含对象实例数据与类型数据的地址信息。**优点**是在对象被移动的过程中只需要改变句柄池的数据即可，不需要改变reference；**缺点**是相比直接访问，速度较慢
2. 直接指针访问。reference中存储的直接就是对象地址，对象移动，reference需要相应改变。但是由于是直接访问，所以速度较快，HotSpot虚拟机正是使用此种访问方式

## 第3章 垃圾收集器与内存分配策略

---

### 3.1 概述

程序计数器、虚拟机栈、本地方法栈3个区域的生命周期和线程一样，栈中的栈帧随着方法的进入和退出执行入栈和出栈操作，**每一个栈帧中分配多少内存基本上是在类结构确定下来时就已经知道**，当方法结束或线程结束，内存就被回收

### 3.2 对象已死？

#### 3.2.1 引用计数器

在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值加一；引用消失时，计数器值减一，计数器值为零的对象不能再被使用

**优点**：简单直接，判定效率高；

**缺点**：很难解决相互引用的问题

#### 3.2.2 可达性分析算法

通过“**GC Roots**”的跟对象作为起始节点集，从这些节点出发，根据引用关系往下搜索，搜索的路径称为引用链，如果某个对象到GC Roots没有任何引用链，则证明此对象不可能再被使用

固定可作为GC Roots的对象包括如下几种：

* 虚拟机栈（*栈帧中本地变量表*）中引用的对象，例如方法堆栈中使用的参数、局部变量、临时变量等
* 方法区中*类静态属性引用的对象*，譬如Java类的引用类型静态变量
* 方法区中*常量引用的对象*，譬如字符串常量池的引用
* 本地方法栈中引用的对象
* Java虚拟机内部的引用，如基本数据类型的Class对象，一些常驻异常（OOM、空指针）还有系统类加载器
* 被同步锁持有的对象

如果只针对堆中某个区域回收，某个区域的对象完全可能被位于堆中其他区域的对象所引用，这时候就需要将这些管理区域的对象一并加入GC Roots中才能保证可达性分析的正确性

#### 3.2.3 再谈引用

传统引用的定义：**如果reference类型数据中存储的数值代表的是另一块内存的起始地址，就称该reference数据是代表某块内存、某个对象的引用**

JDK1.2之后，Java将引用分为：**强引用（Strongly Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）**

* 强引用：传统引用，类似`Object obj = new Object()`。无论什么情况下，只要强引用还存在，垃圾收集器就不会回收掉被引用的对象
* 软引用：描述一些还有用，但非必须的对象。被软引用关联的对象，在系统将要发生内存溢出前，会把这些对象列进回收范围进行第二次回收，如果回收完之后还没有足够的内存，将抛出异常
* 弱引用：被弱引用关联的对象只能生存道下一次垃圾收集器发生为止
* 虚引用：“幽灵引用”，最弱的引用关系，一个对象的虚引用完全不会对该对象的生存时间造成影响，无法通过虚引用来获得该对象，**虚引用的唯一目的是为了这个对象在被回收器回收时能收到一个通知**

#### 3.2.4 生存还是死亡？

在可达性分析中判定为不可达的对象**并非“非死不可”**，真正判别一个对象的死亡**最多经历两个标记过程**。

1. 如果对象在可达性分析后发现没有与GC Roots相连接的引用链，那么将被第一次标记
2. 随后进行一次筛选，筛选条件是该对象**是否有必要执行finalize方法**，假如该对象没有覆盖finalize方法或者虚拟机已经调用过了该方法，此时就没必要执行（finalize方法只会被执行一次）

被执行的finalize方法会被放置在一个**F-Queue队列**中，由虚拟机建立的低调度优先级的Finalizer线程执行。在第二阶段，也就是执行finalize方法方法时，该对象只要重新与引用链上的一个对象建立关联，那么该对象就可以被移除回收集合，救赎成功。

#### 3.2.5 回收方法区

方法区垃圾收集器的收集成果较低，主要回收两部分内容：**废弃的常量和不再使用的类型**

例如一个字符串“Java”进入常量池后**没有任何字符串对象引用这个常量，且虚拟机中也没有引用该常量**，收集器就可以对将该常量清理出常量池

**判断不再使用的类型的条件**

1. 该类的所有实例都被回收（包括派生子类）
2. 该类的类加载器被回收（一般很难满足）
3. 该类对应的**java.lang.Class对象没在任何地方被引用，且无法通过反射访问该类的方法**

### 3.3 垃圾回收算法

“引用计数式垃圾收集”和“追踪式垃圾收集”。**主流Java虚拟机主要应用的是“追踪式垃圾收集”**

#### 3.3.1 分代垃圾收集理论

分代收集理论建立在以下三个假说下

1. **弱分代假说**：绝大数对象都是朝生夕灭
2. **强分代假说**：熬过越多次垃圾收集过程的对象越难以消亡

设计者一般将Java堆设计为新生代和老年代。在新生代中每次垃圾回收都发现有大批对象死去，而每次回收后少了存活的对象将逐步晋升到老年代中。

> 对象在Eden区诞生，虚拟机为每个对象定义了一个**对象年龄计数器**，存储在对象头之中，如果经历过一次Minor GC后仍然存活并且能被Survivor容纳的话，将被移到Survivor区，并且年龄+1，当年龄到一定程度时对象可以晋升到老年代。——参见3.8.3节

3. **<span id="跨代引用">跨代引用假说</span>**：如果要进行一次Minor GC，但**新生代中的对象可能引用了老年代中的对象，此时不得不在已经固定GC Roots之外再遍历整个老年代中所有对象保证可达性分析的正确性**

为了避免少量的跨代引用而照成扫描整个老年代，只需要**在新生代上建立一个全局数据结构[记忆集](#记忆集)，这个结构把老年代划分成若干小块，标识出老年代的那一块内存会存在跨代引用**

#### 3.3.2 标记-清除算法

**标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象（也可以标记存活的，回收未标记的）**

**优点**：简单易理解；不涉及对象的移动和复制，执行速度较快

**缺点**：执行效率不稳定，如果堆中大部分对象是存活的，那么标记和清除的执行效率会很低；其次主要是内存空间碎片问题，标记清除后产生大量不连续的内存空间，当要分配大对象时可能找不到一个足够大的连续空间从而提前触发垃圾回收

#### 3.3.3 标记-复制算法

**将内存划分成大小相等的两块，每次使用其中一块，当一块快要用完时，将存活的对象复制到另一块，同时把已经使用的内存空间一次清理掉。**

**优点**：不会产生空间碎片问题

**缺点**：如果存活对象多的话，复制开销会很大；每次只使用一半的空间，空间利用率低

因为新生代中98%的对象都熬不过第一轮收集，因此不需要按照1:1划分空间

**Appel式回收**

把新生代分成一个Eden和两个Survivor空间（通常8:1:1），每次分配只使用Eden空间和其中一块Survivor空间，发生垃圾回收时将Eden空间和Survivor空间中存活的对象复制到另一块未使用的Survivor空间中，同时清理掉已经使用的Eden和Survivor空间

其中Serial、Parnew等新生代收集器都是使用Appel策略的空间布局

**逃生门设计**

当Appel回收的Survivor空间不足以容纳一次Minor GC后存活的对象时，需要老年代进行分配担保，存活的对象可以通过担保机制直接进入老年代（参见[3.8.5](#空间担保)节担保机制）

#### 3.3.4 标记-整理算法

**标记过程与标记清除算法一样，但是后续不是直接对可回收对象进行清理而是将所有存活的对象向一端移动，然后清理边界以外的内存**

注意，这里并不涉及对象的复制

在移动这些对象并更新所有引用这些对象的地方必须暂停所有应用程序才能进行，也就是“**Stop The World”**。**ZGC和Shenandoah收集器使用读屏障技术实现整理和用户线程并发**

**优点**：不会造成空间碎片；不会浪费空间

**缺点**：移动对象造成内存回收复杂，会造成STW

Parallel Old收集器是基于标记-整理算法，关注延迟的CMS则使用的是标记清除算法

### 3.4 HotSpot的算法细节实现

#### 3.4.1 根节点枚举

由于所有收集器在进行根节点枚举的时候都必须暂停用户线程，因此根节点枚举和之前的标记整理算法一样都面临这**STW**问题，但是由于目前主流的JVM都是[准确式垃圾回收](#准确式垃圾回收)，在编译完成之后，虚拟机就可以把对象内什么偏移量上是什么类型的数据计算出来，因此当用户线程停止之后并不需要一个不漏的检查完所有上下文引用。

**<span id="准确式垃圾回收">准确式垃圾回收</span>**：虚拟机可以知道内存中某个位置的数据具体是什么类型

当类加载完成，HotSpot中使用**OopMap的数据结构**来记录对象内存地址上的类型数据，同时会在特点的位置记录下栈里和寄存器里的那些位置式引用

#### 3.4.2 安全点

由于OopMap的存在，HotSpot虚拟机可以很快的完成GC Roots的枚举，但是HotSpot没有为每条指令都生成OopMap，只在特定的位置记录由于指令造成的引用变化，而这些特定的位置称为**安全点**

**安全点的设计，强制用户线程并不是任意位置都可以停顿下来进行GC，而必须强制达到安全点之后才能暂停**

产生安全点的指令：方法调用、循环跳转、异常跳转等指令复用序列

**如何让垃圾回收时，所有线程跑到最近的安全点，然后暂停？**

* 抢占式中断：在GC发生时，系统把所有用户线程中断，如果发现有用户线程不在安全点，则恢复这条线程执行，让它跑一会再中断，直到到达安全点
* 主动式中断：设置一个标志位，用户线程在执行时不停的轮询这个标志，一旦发现标志为真，线程就在最近的安全点暂停挂起

#### 3.4.3 安全区域

安全区域指能够保证在一段代码中，引用关系不发生变化，因此，在这个区域中任意地方开始GC都是安全的

当用户线程进入安全区域，会标识自己进入安全区域，当离开时会检查虚拟机是否完成了根节点枚举，如果完成了，那线程当没事发生过，否在一直等待，直到收到可以安全离开的信号

#### 3.4.4 <span id="记忆集">记忆集和卡表</span>

为了解决[跨代引用](#跨代引用)问题，垃圾收集器在新生代中建立了记忆集避免扫描整个老年代，这个结构把老年代划分成若干小块，标识出老年代的那一块内存会存在跨代引用。

**记忆集是一种用于记录从非收集区域指向收集区域的指针集合的抽象数据结构**

常见的记忆集实现结构为**”卡表“(CARD_TABLE)**

卡表最简单的形式是一个字节数组，卡表的每一个元素对应这一块特定大小的内存块，这个内存块被称为**卡页**，在HotSpot中卡页的大小是2的9次幂，即512字节

一个卡页可以包含多个对象，只要其中存在跨代引用，那就将对应卡表的数组元素的标志为1，称这个元素变脏，在GC时筛选出变脏的元素一起加入GC Root一并扫描

#### 3.4.5 写屏障

卡页变脏的条件：其他分代中引用了本区域对象时，该卡页变脏

在HotSpot中通过**写屏障**来进行来维护卡表的状态

**写屏障可以看作虚拟机为引用类型赋值动作的AOP切面**，赋值前的写屏障叫写前屏障，赋值后的叫写后屏障

为了解决高并发条件下伪共享问题，不采用无条件写屏障，而是只有在卡表元素未被标记时才将其变脏

#### 3.4.6 三色标记

**白色**：表示对象尚未被垃圾收集器扫描过，垃圾回收开始前，所有对象都是白色

**黑色**：对象已经被垃圾收集器访问过，且这个对象的所有引用都已经被扫描过

**灰色**：表示对象已经被垃圾收集器访问过，但这个对象至少还有一个引用还没有被扫描

高并发情况下三色标记可能会出现错误的结果，例如将原本消亡的对象标记为存活或者将存活的对象标记为消亡

* 赋值器插入一条或多条从黑色对象到白色对象的引用
* 赋值器删除了全部从灰色对象到白色对象的直接或间接引用

**<span id="增量更新">增量更新</span>**可以解决第一种情况，也就是当出现第一种情况时，将**黑色对象变灰，重新扫描一次**；

<b><span id="原始快照">原始快照（SATB）</span></b>可以解决第二种情况，当灰色对象要删除指向白色对象的引用关系时，将这个关系记录下来，当并发扫描结束后，以灰色对象为根重新扫描一次

CMS是基于增量更新做并发标记，G1、Shenandoah则是用的原始快照来实现

### 3.5 经典垃圾回收器

常见的经典垃圾收集器如下所示

![垃圾收集器](https://zixianghu-images.oss-cn-chengdu.aliyuncs.com/%E7%AC%94%E8%AE%B0%E6%8F%92%E5%9B%BE/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.png)

存在连线关系的垃圾收集器说明可以协同工作，譬如Serial可以和Serial Old搭配使用

#### 3.5.1 Serial收集器

Serial收集器是最基础，最悠久的收集器

![](https://zixianghu-images.oss-cn-chengdu.aliyuncs.com/%E7%AC%94%E8%AE%B0%E6%8F%92%E5%9B%BE/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/Serial%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.png)

**特点**：

* 单线程工作，需要STW，标记-复制算法
* 客户端默认的新生代收集器
* 消耗内存最小

#### 3.5.2 ParNew收集器

ParNew收集器实质上是Serial收集器的多线程版本

![](https://zixianghu-images.oss-cn-chengdu.aliyuncs.com/%E7%AC%94%E8%AE%B0%E6%8F%92%E5%9B%BE/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/ParNew%E6%94%B6%E9%9B%86%E5%99%A8.png)

ParNew收集器是JDK7之前系统首选的新生代收集器，**除了Serial收集器外，目前只有ParNew收集器能与CMS收集器配合工作**，是激活CMS收集器默认的新生代收集器

#### 3.5.3 Parallel Scavenge收集器

Parallel Scavenge收集器同样是基于标记-复制算法实现，但与CMS等收集器不同的是，**Parallel Scavenge关注的是可控制的吞吐量，而CMS关注的是缩短垃圾收集时用户停顿的时间**

> 吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)

Parallel Scavenge收集器提供了两个参数用于精确控制吞吐量， 分别是控制最大垃圾收集停顿时间的-XX： MaxGCPauseMillis参数以及直接设置吞吐量大小的-XX： GCTimeRatio参数  。除此之外，Parallel Scavenge收集器还有一个参数-XX： +UseAdaptiveSizePolicy ，称为自适应策略，不需要人工指定Eden、Survicor区

#### 3.5.4 Serial Old收集器

Serial收集器的老年代版本，同样是单线程收集器使用**标记整理算法**，主要意义也是**提供客户端模式下的HotSpot虚拟机使用，另一种作用就是CMS并发失败后的预备方案**

![](https://zixianghu-images.oss-cn-chengdu.aliyuncs.com/%E7%AC%94%E8%AE%B0%E6%8F%92%E5%9B%BE/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/Serial%20Old%E6%94%B6%E9%9B%86%E5%99%A8.png)

#### 3.5.5 Parallel Old收集器

Parallel Scavenge收集器的老年代版本，支持多线程并发收集，基于**标记整理算法**

在JDK6之前，新生代的Parallel Scavenge收集器只能与Serial Old收集器搭配使用，直到Parallel Old出现，”吞吐量优先“的收集器才算完整

![](https://zixianghu-images.oss-cn-chengdu.aliyuncs.com/%E7%AC%94%E8%AE%B0%E6%8F%92%E5%9B%BE/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/Parallel%20Old%E6%94%B6%E9%9B%86%E5%99%A8.png)

#### 3.5.6 CMS收集器

Concurrent Mark Sweep，以一种获取最短回收停顿时间为目标的老年代垃圾收集器，**基于标记清除算法**

CSM的垃圾回收步骤分为四个步骤

1. **初始标记**

标记GC Roots能够直接关联到的对象是，需要STW

2. **并发标记**

从GC Roots的直接关联对象开始扫描整个对象图

3. **重新标记**

该阶段是为了修正并发标记阶段，因用户线程继续运行而导致的标记变动（[增量更新](#增量更新)）

4. **并发清除**

清理删除掉标记为死亡的对象，不涉及对象的移动，因此**不需要暂停用户线程**

![](https://zixianghu-images.oss-cn-chengdu.aliyuncs.com/%E7%AC%94%E8%AE%B0%E6%8F%92%E5%9B%BE/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/CMS%E6%94%B6%E9%9B%86%E5%99%A8.png)

**CMS收集器的缺点**

1. CMS收集器对处理器资源非常敏感，会占用一部分线程导致应用程序变慢，默认启动的回收线程数是（处理器核心数量+3）/4
2. CMS无法处理”浮动垃圾“，有可能出现并发失败而导致一次完全的STW

由于并发标记阶段，用户线程在继续运行，因此自然有新垃圾产生，但这部分垃圾CMS无法处理，只有下一次收集时才能回收

同样，由于用户线程在继续运行，因此CMS需要预留一部分空间供并发的程序使用，不能等老年代空间快要填满时才开始收集（JDK6之后CMS使用92%空间就会被激活），要是CMS预留的空间不够用户线程分配大对象时，会出现并发失败，此时虚拟机必须冻结用户线程，而启用Serial Old来收集

3. 由于CMS基于**标记清除算法**，因此意味着收集结束后会产生空间碎片，会给大对象的分配造成麻烦，从而提前触发一次全局的 Full GC

#### 3.5.7 G1收集器

Garbage First收集器**开创了收集器<font color='red'>面向局部收集的设计思路和基于Region的内存布局</font>形式**

JDK9发布时，G1取代Parallel+Parallel Old成为服务端默认的收集器，现在JDK13默认的收集器也是G1

**G1的特点**

1. G1把内存划分为若干个Region进行管理，G1虽然保留了分代设计的思想，但是不再物理隔离，每一个Region根据需要既可以扮演Eden区域、Survivor区域甚至老年代
2. 对于大对象（超过Region一半），G1中使用Humongous区域来存储（超过Regison大小的对象，用多个连续的Humongous存储，并作为老年代来看待）
3. G1将一个Region作为最小的可回收单元，去跟踪每个Region的价值大小（根据垃圾的数量和回收时间来评判价值），然后后台维护一个优先队列，优先回收价值最大的Region
4. G1的停顿时间可以预测，能够指定最大的停顿时间（-X:MaxGCPauseMillis ）
5. G1能够充分利用多核多线程的优势，尽量缩短STW的时间
6. G1整体上是**标记整理算法**，但是从两个Region之间看是**标记复制算法**，因此不会产生空间碎片

**G1的问题**

* G1的记忆集更复杂，每个Region都会维护自己的记忆集，这些记忆集会记录别的Region指向自己的指针，并标记指针分别位于哪些卡页的范围之内，其**记忆集是双向设计（记录了我指向谁和谁指向我）**，同时Region的数量较多，所以**消耗的内存空间大**
* G1使用[原始快照SATB](#原始快照)解决并发标记阶段引用改变的问题，同时用户线程运行期间，为了存储新产生的对象，每个Region设计了两个**TAMS（Top at Mark Start）**的指针，把Region中的一部分区域划分出来作为新对象的分配，并且默认这个地址上的对象是被标记存活的

![](https://zixianghu-images.oss-cn-chengdu.aliyuncs.com/%E7%AC%94%E8%AE%B0%E6%8F%92%E5%9B%BE/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/G1%E6%94%B6%E9%9B%86%E5%99%A8.png)

G1收集器的过程与CMS比较类似，差别在于最终标记阶段和筛选回收阶段

1. **初始标记**

标记GC Roots能够直接关联到的对象是，需要STW，需要停顿用户线程

2. **并发标记**

从GC Roots开始对堆中的对象进行可达性分析，当扫描完成后处理SATB中变动的对象

3. **最终标记**

对用户线程进行暂停，使用原始快照算法处理并发标记阶段变动的引用关系

4. **筛选回收**

对Region的价值进行排序，根据用户期望的停顿时间进行Regison回收，多个Region组合成回收集，把回收的Region中存活的对象复制到空的Region中，再清理旧的Region。**这里涉及移动对象，因此必须暂停用户线程**

**G1与CMS的对比**

* G1可以指定最大停顿时间、分Region布局、按收益回收、不会产生空间碎片
* G1的内存占用和执行负载比CMS高
  * G1的卡表更复杂，每个Region都维护了卡表；而CMS只有一份，只需要处理老年代到新生代的引用
  * CMS用写后屏障进行卡表的维护；而G1除了使用写后屏障，为了实现原始快照，还**使用写前屏障跟踪指针的变化情况**

### 3.6 低延迟垃圾收集器

#### 3.6.1 Shenandoah收集器、

目标是**实现任何堆内存大小都可以把GC时间限制在十毫秒以内**，该目标意味着，除了并发标记外还要进行并发的整理

**Shenandoah的特点**

1. 与G1有相似的堆内存布局，都是基于Region的内存管理，同样有着存储大对象的Humongous Region，默认回收策略也是价值最大的Region
2. Shenandoah收集器**支持垃圾清理后并发的整理**
3. Shenandoah收集器目前并**不使用分代收集**
4. Shenandoah收集器摒弃了在G1中耗费大量内存和计算资源去维护的记忆集，改用“连接矩阵”的全局数据结构来记录Region的引用关系，降低了资源消耗的同时也降低了伪共享问题

**Shenandoah的工作流程**

* **初始标记**

该阶段与G1一致，需要STW

* **并发标记**

与G1一致，并发的遍历图

* **最终标记**

与G1一致，处理剩余的SATB扫描，并在这个阶段统计出价值最高的Region，将这些Region组成会收集（CSet）

* **并发清理**

这个阶段用于清除一个存活对象都没有的Region

* **并发回收**

这个阶段涉及Region的复制，把回收Region中存活的对象移动到未使用的Region中，与G1不同的是，Shenandoah收集器这里并没有冻结用户线程，因此移动之后整个内存中所有指向旧对象的引用还是旧对象的地址，对于这个问题**Shenandoah收集器利用读屏障和[Brooks Pointers](#转发指针)来解决**

* **引用更新**

并发回收阶段复制对象结束后，把**堆中所有指向旧对象的引用修正到复制后的新地址**

* **并发清理**

解决了堆中引用更新问题后，并发清理掉剩余待收集的Region

简单来说，Shenandoah收集器的工作流程可以分为**并发标记、并发回收和并发引用更新三个阶段**

**保护陷阱**

在被移动对象原有内存上设置保护陷阱，一旦用户线程访问了旧对象的空间就会产生自陷中断，进入预设的异常处理，再由其中的逻辑代码将访问转发到新对象上

**<span id="转发指针">Brooks Pointers(转发指针)</span>**

在原有对象布局结构最前面统一增加一个新的引用字段，在正常不处于并发移动情况下，该引用指向对象自己（有点类似句柄访问，不过句柄专门放在句柄池，转发指针放在每个对象头前）

转发指针带来的缺点就是**每次访问对象都会有一次额外的转向开销**，带来的好处就是**每次只需要修改一处指针的位置，即旧对象上转发指针的引用位置，使其指向新对象，便可将所有对新对象的访问转发到新副本上**。同时为了解决高并发情况下对象访问的正确性，Shenandoah使用CAS来保证并发的正确性

同时由于对象引用关系的变化，**Shenandoah同时设置了读写屏障保证对象访问操作的正确性**（之前用于卡表维护的操作中，只用到了写屏障），为了解决读操作频繁而带来的性能问题，**在JDK13中**，Shenandoah将内存屏障问题改为了**基于引用访问屏障的实现**，也就是只拦截引用数据类型的读写操作，不管原生数据类型的读写

#### 3.6.2 ZGC收集器

目标与Shenandoah收集器基本一样，实现在任意堆内存大小下都可以把垃圾收集的停顿时间限制在十毫秒以内的低延迟。

**ZGC特点**

* 基于Region的堆内存布局，与G1和Shenandoah相似但却又不同，**ZGC的Region具有动态性**，可以动态的创建、销毁及具有动态的容量大小（在x64平台上具有大中小三种Region）
* 暂时不设分代
* 使用了**[染色指针](#染色指针)、读屏障和内存映射**（没有写屏障）
* **基于可并发的标记整理算法**
* 不需要维护记忆集，完全没有用到写屏障

**<span id="染色指针">染色指针（Colored Pointer）</span>**

之前在对象上存储一些额外的，只供收集器或者虚拟机本身使用的数据，**一般在[对象头](#对象头)中增加额外的存储字段**,，如哈希码、分代年龄锁记录等。而**ZGC的染色指针直接把这些标记信息记录在引用对象的指针上**

**染色指针是一种直接将少量额外信息存储在指针上的技术，在Linux下的64位指针的高18位不能用来寻址，ZGC使用剩下46位的高4位来存储四个标志信息，通过这四个标记信息，可以直接从指针中看到其引用对象的三色标记状态、是否进入重分配集（即被移动过）、是否只有通过finalize()方法才能被访问到，这也导致ZGC能管理的内存最大是2的42次幂（4TB）**

![](https://zixianghu-images.oss-cn-chengdu.aliyuncs.com/%E7%AC%94%E8%AE%B0%E6%8F%92%E5%9B%BE/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%9F%93%E8%89%B2%E6%8C%87%E9%92%88.png)

**ZGC的优势**

* 染色指针可以使一旦某个Region的存活对象被移走之后，这个Region立刻就能被回收，不必像Shenandoah那样等待引用更新（因为有**转发表**的存在）
* 由于使用的指针技术，不用再使用写屏障去追踪指针变化，目前**ZGC只使用了读屏障，运行效率较高**
* 染色指针还可以进一步扩展，比如将高18位也利用起来
* 支持NUMA（非统一内存访问架构，**ZGC会优先尝试在请求线程当前所处的处理器的本地内存上分配对象，保证高效的内存访问**），在此之前只有吞吐量的Parallel Scavenge支持

**ZGC的工作流程**

ZGC的工作流程可以大致分为四个阶段：**并发标记（其中初始标记小阶段也会STW）、并发预备重分配、并发重分配、并发重映射**

![](https://zixianghu-images.oss-cn-chengdu.aliyuncs.com/%E7%AC%94%E8%AE%B0%E6%8F%92%E5%9B%BE/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/ZGC%E6%94%B6%E9%9B%86%E5%99%A8.png)

1. **并发标记**

与G1和Shenandoah类似，其中扫描GC Roots的直接关联对象时也会短暂的STW。**不过ZGC的标记是在指针上进行的，标记阶段会更新染色指针中的M0和M1标志位**

2. **并发预备重分配**

将回收的Region组成**重分配集**(与CSet有区别)，**ZGC每次都会进行全堆标记，省去了G1中的记忆集的维护成本**，重分配集中的Region中的存活对象会被重新复制到其他的Region中，里面的Region将被释放。**ZGC支持的类型卸载及弱引用处理也是该阶段完成**

3. **<font color='red'>并发重分配</font>**

重分配阶段需要将重分配集中的存活对象复制到新的Region中，并**为重分配集中的每个Region维护一个转发表**，记录从旧对象到新对象的转向关系

**ZGC借助染色指针就可以知道一个对象是否位于重分配集，如果用户线程此时访问了重分配集中的对象，这次访问将被读屏障拦截，然后根据Region上的转发表将访问转发到新的对象上，同时修正更新引用的值，使其指向新对象，该过程称为指针的<font color='red'>自愈</font>**

由于染色指针的存在，相比Shenandoah收集器，ZGC只有第一次访问旧对象会陷入转发，也就是只慢一次，并且由于转发表的存在，当Region中的存活对象复制完毕之后，哪怕堆中还有很多指向这个对象的引用指针没更新，也可以回收掉这个Region，通过自愈可以很好的解决这个问题

4. **并发重映射**

重映射是修正整个堆中指向重分配集中旧对象的所有引用（与Shenandoah类似），但是该过程并不是必须迫切完成的，因为有转发表的存在，即使是旧引用也可以治愈。因此ZGC中将并发重映射合并到了下一次并发标记中，反正都要遍历全部对象，省掉了一次遍历，当所有旧引用更新完成之后旧可以清理掉转发表

### 3.7 合适的垃圾收集器

#### 3.7.1 Epsilon收集器

Epsilon收集器是一款不能收集垃圾的收集器

垃圾收集器除了垃圾收集功能外，还需要负责堆的管理与布局、对象分配、与解释器和编译器协同等工作，而Epsilon收集器正是一款这样的收集器

#### 3.7.2 收集器权衡

根据需求和情况选择，没有最好的只有最适合的

#### 3.7.3 虚拟机及垃圾回收日志

1. 查看GC基本信息， 在JDK 9之前使用-XX： +PrintGC， JDK 9后使用-Xlog： gc：  
2. 查看GC详细信息， 在JDK 9之前使用-XX： +PrintGCDetails， 在JDK 9之后使用-X-log： gc*  
3. 查看GC前后的堆、 方法区可用容量变化， 在JDK 9之前使用-XX： +PrintHeapAtGC， JDK 9之后使用-Xlog： gc+heap=debug：  

### 3.8 内存分配与回收策略

对象的内存分配，一般是直接在堆上分配，在经典分代的设计下，新生对象一般分配到新生代，少数情况（例如大对象）直接分配到老年代

#### 3.8.1 对象优先在Eden分配

对象在新生代的Eden中分配，如果Eden中没有足够空间将发起一次Minor GC

```java
//-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:+UseSerialGC
public class AllocationTest {

    private static final int _1MB = 1024 * 1024;

    public static void testAllocation() {
        byte[] allocation1, allocation2, allocation3, allocation4;
        allocation1 = new byte[2 * _1MB];
        allocation2 = new byte[2 * _1MB];
        allocation3 = new byte[2 * _1MB];
        allocation4 = new byte[4 * _1MB];
    }

    public static void main(String[] args) {
        testAllocation();
    }
}
```

>[GC (Allocation Failure) [DefNew: 8126K->626K(9216K), 0.0028817 secs] 8126K->6770K(19456K), 0.0029247 secs] [Times: user=0.02 sys=0.00, real=0.00 secs] 
>Heap
> def new generation   total 9216K, used 4804K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)
>  <font color='red'>eden space 8192K,  51% used</font> [0x00000000fec00000, 0x00000000ff014930, 0x00000000ff400000)
>  from space 1024K,  61% used [0x00000000ff500000, 0x00000000ff59cab0, 0x00000000ff600000)
>  to   space 1024K,   0% used [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000)
> <font color='red'>tenured generation   total 10240K, used 6144K </font>[0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)
>   the space 10240K,  60% used [0x00000000ff600000, 0x00000000ffc00030, 0x00000000ffc00200, 0x0000000100000000)
> Metaspace       used 3232K, capacity 4496K, committed 4864K, reserved 1056768K
>  class space    used 350K, capacity 388K, committed 512K, reserved 1048576K

分析：当分配allocation4时，Eden区域空间不足，因此会触发一次GC，但是由于allocation1，allocation2和allocation3都还存活的，且Survivor区（只有1M）放不下这三个东西，因此allocation1，allocation2和allocation3通过担保机制进入老年代，而此时allocation4才在Eden中获得分配

#### 3.8.2 大对象直接进入老年代

HotSpot虚拟机提供了**-XX:PretenureSizeThreshold参数**， 指定大于该设置值的对象直接在老年代分配， 这样做的目的就是避免在Eden区及两个Survivor区之间来回复制， 产生大量的内存复制操作  

```java
public class PretenureSizeThresholdTest {
    private static final int _1MB = 1024 * 1024;
//-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:+UseSerialGC -XX:PretenureSizeThreshold=3145728
    public static void main(String[] args) {
        byte[] allocation;
        allocation = new byte[4 * _1MB];
    }
}
```

下面两个输出日志分别对应未使用和使用-XX:PretenureSizeThreshold=3145728的情况。很明显，当使用了PretenureSizeThreshold参数后，allocation直接被分配进了老年代

>Heap
> def new generation   total 9216K, used 6242K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)
><font color='red'>eden space 8192K,  76% used</font> [0x00000000fec00000, 0x00000000ff218b50, 0x00000000ff400000)
>from space 1024K,   0% used [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000)
>to   space 1024K,   0% used [0x00000000ff500000, 0x00000000ff500000, 0x00000000ff600000)
><font color='red'> tenured generation   total 10240K, used 0K </font>[0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)
>the space 10240K,   0% used [0x00000000ff600000, 0x00000000ff600000, 0x00000000ff600200, 0x0000000100000000)
> Metaspace       used 3203K, capacity 4496K, committed 4864K, reserved 1056768K
>class space    used 346K, capacity 388K, committed 512K, reserved 1048576K

>Heap
> def new generation   total 9216K, used 2146K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)
>  <font color='red'>eden space 8192K,  26% used</font> [0x00000000fec00000, 0x00000000fee18b40, 0x00000000ff400000)
>  from space 1024K,   0% used [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000)
>  to   space 1024K,   0% used [0x00000000ff500000, 0x00000000ff500000, 0x00000000ff600000)
> <font color='red'>tenured generation   total 10240K, used 4096K</font> [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)
>   the space 10240K,  40% used [0x00000000ff600000, 0x00000000ffa00010, 0x00000000ffa00200, 0x0000000100000000)
> Metaspace       used 3202K, capacity 4496K, committed 4864K, reserved 1056768K
>  class space    used 346K, capacity 388K, committed 512K, reserved 1048576K

#### 3.8.3 长期存活的对象将进入老年代

虚拟机给每个对象定义了一个对象年龄，存储在对象头之中，如果经历过一次Minor GC后仍然存活并且能被Survivor容纳的话，将被移到Survivor区，并且年龄+1，对象在Survivor区域中每经历一次MinorGC，年龄就会+1，当年龄到一定程度时对象可以晋升到老年代。年龄的设置可以通过**-XX: MaxTenuringThreshold 参数**设置

#### 3.8.4 动态年龄判断

为了能更好地适应不同程序的内存状况，**HotSpot虚拟机并不是永远要求对象的年龄必须达到MaxTenuringThreshold才能晋升老年代**，**如果在Survivor空间中低于或等于某个年龄的对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代**，无须等到MaxTenuringThreshold中要求的年龄  

#### 3.8.5 <span id="空间担保">空间担保分配</span>

在发生Minor GC之前，**虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总空间**， 如果这个条件成立， 那这一次Minor GC可以确保是安全的。如果不成立，则虚拟机会先查看 HandlePromotionFailure参数的设置值是否允许担保失败（Handle Promotion Failure）； 如果允许，那会继**续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小**， 如果大于，将尝试进行一次Minor GC，尽管这次Minor GC是有风险的；如果小于，或者HandlePromotionFailure设置不允许冒险，那这时就要改为进行一次Full GC 

## 第6章 类文件结构

### 6.2 无关性基石

Java虚拟机不与包括Java语言在内的任何程序语言绑定，它**只与“Class文件”这种特定的二进制文件所关联**，Class文件中包含了Java虚拟机指令集、符号表及若干辅助信息

### 6.3 Class类文件的结构

Class文件是一组**以8个字节为基础单位的二进制流**。当需要占用8个字节以上空间的数据项时，会按照高位在前的方式分割成若干个8个字节存储

Class文件类似于C语言中的伪结构体，其只包含两种类型的数据：**无符号数**和**表**

* **无符号数**

基本的数据类型，以u1,u2,u4,u8代表1个字节、2个字节、4个字节和8个字节的无符号数

* **表**

由多个无符号数或者其他表组成的复合数据结构，所有的表名以“_info”结尾，**整个Class文件都可以看作一张表**

#### 6.3.1 魔数与Class文件的版本

Class文件的**前4个字节**被称为“魔数”，唯一作用是确定这个文件是否为一个能被虚拟机虚拟机接受的Class文件

紧接着魔数的**4个字节**，也就是5~8字节，存储的是Class文件的**版本号**

#### 6.3.2 常量池

版本号之后就是**常量池入口**，由于常量池中常量的数量不是固定的，因此**常量池入口放置了一个u2类型的数据，代表该常量池的容量**

值得注意的是，**常量池容量从1开始而不是Java语言中的0**，例如容量是22（0x0016）的常量池代表池中有21个常量（1~21），**索引为0的常量代表了“不引用任何一个常量池项目”**。Class文件中只有常量池是从1开始计数

常量池中主要存放两大类常量：**<span id="字面量和符号引用">字面量和符号引用</span>**

* **字面量**

字面量和Java语言中的常量概念近似，例如文本字符串、被final修饰的常量值

* **符号引用**

  * 被模块导出或开放的包
  * 类和接口的全限定名
  * 字段的名称和描述符号
  * 方法的名称和描述符号
  * 方法的句柄和方法类型
  * 动态调用点和动态常量

  **符号引用需要在类加载过程中通过解析转换为直接引用才能得到真正的内存地址**

常量池中每项常量都是一个表，**截至JDK13，常量表中有17种不同类型的常量**

这17个常量的**第一个字节都是tag**，表名了这个常量的类型，通过这个tag就可以确定它是什么类型的常量

#### 6.3.3 访问标志

**常量池之后，接着两个字节代表的是访问标志**，用于识别一些类或者接口层次的访问信息：例如这个Class是类还是接口；是否定义为public；是否抽象等等

#### 6.3.4 类索引、父类索引与接口索引集合

**类索引和父类索引都是一个u2类型的数据，而接口索引是一组u2类型的数据集合**

类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名

父类索引之后的u2类型称为**接口计数器**，表示实现的接口数量

> 00 01 00 03 00 00
>
> 例如上面的一组数据，00 01代表了这个类的类索引；00 03代表了其父类的索引；00 00代表这个类实现的接口数量为0 

#### 6.3.5 字段表集合

**字段表**用于描述接口或者类中声明的变量，**包括类变量和实例级变量**

和常量池一样，第一个u2类型标识字段的数量，之后就是一个字段表结构，包括：一个u2类型的访问标识；一个u2类型的简单名称；一个u2类型的描述符、一个u2类型的属性表数量和属性表

> 00 01 00 02 00 05 00 06 00 00 
>
> 例如上面的00 01代表字段表中只有一个字段；00 02代表该字段是private；00 05代表该字段的简单名称对应常量池中的第5项；00 06说明该字段的描述符号是常量池中的第6项；之后的00 00说明该字段没有属性表

#### 6.3.6 方法表集合

方法表集合的结构几乎与字段表集合一致，开始是一个u2类型的方法数量标志；接着分别是访问标识、名称索引、描述符索引、属性表集合

> 00 02 00 01 00 07 00 08 00 01 00 09
>
> 例如上面的00 02说明该类或接口有两个方法（包括构造器）；00 01说明这个方法的访问权限是public；00 07说明这个方法的简单名称对应常量池第7项；00 08说明这个方法描述符索引对应常量池第8个；00 01说明属性表中有一个属性；00 09说明该属性对应常量池第9项

#### 6.3.7 属性表集合

Java虚拟机最初只定义了9项属性；再Java SE 12版本中，预定义属性增加到了29种

例如**Code属性，代表Java代码编译成的字节码指令**；ConstantValue属性代表由final关键字定义的常量值等等

### 6.4 字节码指令简介

Java虚拟机的指令是由一个字节长度的**操作码**以及其后的零或多个代表此操作的**操作数构成**

#### 6.4.1 字节码与数据类型

Java虚拟机中大部分指令都没有支持byte,char和short，甚至没有指令支持boolean，**编译器会在编译期或运行时对这几种类型扩展为int类型**

#### 6.4.2 加载和存储指令

1. **将局部变量加载到操作数栈**：iload、 iload_<n>、 lload、 lload_<n>、 fload、 fload_<n>、 dload、
   dload_<n>、 aload、 aload_<n>  .这里的**n代表局部变量表中的索引**
2. **将一个数值从操作数栈存储到局部变量表**： istore、 istore_<n>、 lstore、 lstore_<n>、 fstore、
   fstore_<n>、 dstore、 dstore_<n>、 astore、 astore_<n>  。这里的**n代表将数据存储到局部变量表的n位置上**
3. **将一个常量加载到操作数栈**： bipush、 sipush、 ldc、 ldc_w、 ldc2_w、 aconst_null、 iconst_m1、
   iconst_<i>、 lconst_<l>、 fconst_<f>、 dconst_<d>  。这里的i,l等代表常量或者常量池中的数据

**例子说明**

```java
   public void test(int a, double b) {
        int c = 1;
        Object o = new Object();
        long d = 2L;
        char e = 'e';
    }
```

对应的局部变量表，其中局部变量表以slot为单位，一个slot代表4字节，变量b和d一个是double，一个是long，所以占两个slot

| 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| this | a    | b    |      | c    | o    | d    |      | e    |

对应的字节码指令

```bash
 0 iconst_1 #将常量1加载到操作数栈中
 1 istore 4 #将c存储到局部变量表的第4个槽位
 3 new #2 <java/lang/Object>
 6 dup
 7 invokespecial #1 <java/lang/Object.<init>>
10 astore 5 #将o对象存储到5槽位
12 ldc2_w #3 <2> #从常量池中加载2号常量到操作数栈
15 lstore 6 #将d存到槽位6
17 bipush 101 #往操作数栈压入一个常量101，也就是'e'
19 istore 8 #将e存到槽位8
21 return
```

#### 6.4.3 运算指令

算术指令**用于对操作数栈上的两个值进行某种特定运算，并把结果重新存入到操作数栈顶**

**例子说明**

```java
 public void test(int a,int b){
        int c = a + b;
        int d = a * c;
        int e = d % c;
    }
```

对应的局部变量表

| 0    | 1    | 2    | 3    | 4    | 5    |
| ---- | ---- | ---- | ---- | ---- | ---- |
| this | a    | b    | c    | d    | e    |

对应的字节码指令

```bash
 0 iload_1 #将局部变量表1的变量加载到操作数栈
 1 iload_2 #将局部变量表2的变量加载到操作数栈
 2 iadd #将操作数栈上的两个值出栈进行加法运算，并把结果存入栈顶
 3 istore_3 #将操作数栈中的值存到局部变量表3的位置
 4 iload_1
 5 iload_3
 6 imul
 7 istore 4
 9 iload 4
11 iload_3
12 irem
13 istore 5
15 return
```

**i++与++i分析**

**代码1**

```java
  public void test5(){
        int i = 10;
        i++;
        ++i;
    }
```

字节码指令

```bash
0 bipush 10 #将常量10压入操作数栈
2 istore_1 #将10存入局部变量表1的位置，也就是给i赋值为10
3 iinc 1 by 1 #对局部变量位置1的数进行加1
6 iinc 1 by 1 #对局部变量位置1的数进行加1
9 return
```

**结论**：对于没有赋值的i++和++i，从字节码指令上来看都是一样的，实现效果也是一样的

**代码2**

```java
public void test2() {
    int i = 22;
    int j = i++;
    int k = ++i;
}
```

字节码指令

```bash
 0 bipush 22 #向操作数栈中压入常量22
 2 istore_1 #将22存到局部变量表1，也就是i=22
 3 iload_1 #从局部变量表加载索引1的变量到操作数栈
 4 iinc 1 by 1 #对局部变量表1的位置的变量进行+1，也就是此时为23
 7 istore_2 #将操作数栈顶元素存到局部变量表的索引2，也就是索引2的位置的值还是22
 8 iinc 1 by 1 #对局部变量表1的位置的变量进行+1，也就是此时为24
11 iload_1 #从局部变量表加载所以1的变量到操作数栈
12 istore_3 #将操作数栈顶元素存到局部变量表的索引3，也就是索引3的位置的值是24
13 return
```

**结论**：对于赋值的i++和++i，此时的效果是不同的，从字节码指令上来看，i++先将i的值读入到操作数栈中，然后对i进行加1，最后将操作数栈中的值赋值给另一个变量；而++i是先对i加1，再将i的值加载到操作数栈，然后将操作数栈中的值赋值给另一个变量

**代码3**

```java
public void test3(){
    int i  = 10;
    i = i++;
}
```

字节码指令

```bash
0 bipush 10 #将常量10压入操作数栈
2 istore_1 #将栈顶元素10存入局部变量表索引1的位置
3 iload_1 #将局部变量表索引1的值加载到操作数栈
4 iinc 1 by 1 #对局部变量表索引1的值进行加1
7 istore_1 #将操作数栈顶元素存入到局部变量表索引1的位置
8 return
```

**结论**：最后i的值还是10，期间i的值变化10->11->10，最后从11变为10是因为被操作数栈中存储的10给覆盖了



## 第7章 虚拟机类加载机制

### 7.1 概述

Java虚拟机把数据从Class是文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成被虚拟机直接使用的Java类型，这个过程叫虚拟机的类加载机制

### 7.2 类加载的时机

一个类被加载到虚拟机内存到卸载出类型，经历的过程为：加载、验证、准确、解析、初始化、使用、卸载

![](https://zixianghu-images.oss-cn-chengdu.aliyuncs.com/%E7%AC%94%E8%AE%B0%E6%8F%92%E5%9B%BE/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png)

上述几个阶段是交叉混合运行的，会在其中一个阶段执行的过程中调用另一个过程

**《Java虚拟机规范》严格规定了只有以下6种情况需要立即对类进行初始化**

1. 遇到new、getstatic、putstatic或invokestatic这四条字节码指令时，如果该类型没有初始化则必须马上初始化
   * 使用new初始化对象
   * 调用一个类的静态字段（被final修饰的，以及放入常量池的不算）
   * 读取一个类的静态方法
2. 使用反射对类型进行反射调用时
3. 当一个类初始化时，发现其父类还没有被初始化，会先初始化其父类
4. 虚拟机启动指定的主类，虚拟机会先初始化
5. 接口中定义的默认方法，当有这个接口的实现类发生了初始化，那么该接口要在其之前被初始化
6. 当使用JDK7新加入的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic、 REF_putStatic、 REF_invokeStatic、 REF_newInvokeSpecial四种类型的方法句柄， 并且这个方法句柄对应的类没有进行过初始化， 则需要先触发其初始化  

**注意以下几种情况不会触发类的初始化**

1. 通过子类引用父类的静态字段，不会导致子类初始化，只会使父类初始化
2. 通过数组定义引用类，不会触发此类的初始化
3. 常量会在编译器存入调用类的常量池，因此**使用一个类的静态常量不会触发其初始化**

### 7.3 类加载过程

#### 7.3.1 加载

加载过程主要完成以下三个任务

1. 通过一个类的全限定名来获取定义此类的二进制字节流、
2. 将这个字节流代表的静态存储结构转换为方法区的运行时数据结构
3. 在内存中生成该类的一个java.lang.Class对象，最为方法区这个类的数据访问入口

对于数组而言，**数组类不通过类加载器创建，而是Java虚拟机直接在内存中动态构建出来**

**如果数组的组件类型是引用类型，数组的类加载器就是该组件的类加载器；如果数组的组件是基本类型，那么数组的类加载器就是引导类加载器**

#### 7.3.2 验证

验证的目的是保证Class文件的字节流符合虚拟机规范要求，验证阶段大致上可以分为如下四个阶段的验证动作

1. 文件格式验证

验证字节流是否符合Class文件格式的规范，比如是否是CAFEBABE开头，主次版本号是否被虚拟机接受等。只有通过了这个阶段的验证后，字节流才被允许进入虚拟机内存的方法区

2. 元数据验证

对字节码描述的信息进行语义分析。比如这个类是否又父类（除了Object，都有父类）；父类是否继承了被final修饰的类；类中的字段是否与父类冲突等等

3. 字节码验证

该阶段是最复杂的一个阶段，主要通过数据流分析和控制流分析，确定程序语义是合法且符合逻辑的。主要是对Class文件的Code属性进行分析

4. 符号引用验证

最后一个阶段**发生在虚拟机将符号引用转化为直接引用的时候**，这个转换在解析阶段发生。主要目的是检验这个类是否缺少或被禁止访问它所依赖的外部类、方法等资源

#### 7.3.3 准备

准备阶段是为**类变量分配内存并设置初始值**（被static修饰的变量），例如`private static int x = 123`，准备阶段只会给x赋值为0，而123的赋值放在初始化阶段。但是如果是静态常量字段，那么在准备阶段，虚拟机就会直接将其设置为期望的值。比如`private static final int x = 123`，准备阶段赋值直接为123

#### 7.3.4 解析

解析式Java虚拟机**将常量池内的符号引用替换为直接引用的过程**

**符号引用**是以一组符号来描述引用的目标，其与虚拟机的内存布局无关，只要无歧义即可；**直接引用**是直接指向目标的指针、偏移地址或者间接定位目标的句柄，直接引用与虚拟机内存布局相关

#### 7.3.5 初始化

初始化阶段就是**执行类构造器<cinit()>方法的过程**

* <cinit()>方法不由程序员编写，是由编译器自动收集类中的所有类变量的赋值语句和静态代码块构成
* Java虚拟机保证在子类的<cinit()>方法执行前，父类的<cinit()>方法已经执行完毕，因此第一个被执行<cinit()>方法的类是Object
* <cinit()>方法并不是必需的。如果一个类没有静态代码块或者类变量，那么可以不生成<cinit()>方法
* 接口中可以有静态变量，因此仍然会生成<cinit()>方法，此外，接口的实现类初始化时不会执行接口的<cinit()>方法

### 7.4 类加载器

#### 7.4.1 类与类加载器

**对于任意一个类，都必须由它的类加载器和这个类本身一起共同确定其在虚拟机中的唯一性**，每一个类加载器都拥有一个独立的类名称空间。因此比较两个类是否相同必须是由统一类加载器加载才有意义

#### 7.4.2 双亲委派模型

自JDK1.2以来，Java一直保持这三层类加载器、双亲委派的类加载器结构，以下主要针对JDK8及之前的三层结构和双亲委派机制，JDK9及之后的放在之后

* **启动类加载器（Bootstrap Class Loader）**

主要加载**<JAVA_HOME>\lib目录**或者被-Xbootclasspath参数指定的路径中存放的，而且是虚拟机能够识别的

* **扩展类加载器（Extension Class Loader）**

负责加载**<JAVA_HOME>\lib\ext目录**中或者被java.ext.dirs系统变量指定的路径上的类库，在JDK9之后，这种扩展机制被模块化代替

* **应用程序类加载器（Application Class Loader）**

也叫系统类加载器，负责**加载用户类路径下的所有类库**，如果程序没有自定义的类加载器，一般情况这个就是默认的类加载器

**双亲委派模型**

**双亲委派模型要求除了顶层的启动类加载器之外，其余的类加载器都要有自己的父类加载器，类加载器的父子关系一般不是继承的关系实现而是通过使用组合关系来复用父加载器的代码**

**双亲委派模型的工作过程**

如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此**所有的加载请求最终都会传递到最顶层的启动类加载器**，只有当父加载器反馈自己无法完成这个加载请求，子类才会尝试自己去加载

**双亲委派模型的优点**

避免类的重复加载，也保证了 Java 的核心 API 不被篡改

#### 7.4.3 破坏双亲委派模型

到Java模块化出现之前，双亲委派模型出现过3次较大规模的破坏

1. 双亲委派模型在JDK1.2之后才引入，但类加载器一直存在，为了引入双亲委派机制和兼容已有的类加载代码，在JDK1.2之后的java.lang.ClassLoader中添加了一个新的**protected方法findClass()**，并引导用户在编写类加载逻辑时去重写这个方法而**不是loadClass方法**
2. 双亲委派机制很好的解决了基础类一致的问题，但是如果基础类要调用用户的代码（例如JNDI服务），但是基础类的类加载器是启动类加载器，其肯定不会加载用户的代码。此时，Java引入了**线程上下文类加载器（Thread Context ClassLoader）**，这个类加载器可以通过Thread类的setContextClassLoader()进行设置，**如果创建线程时未设置，将继承父线程；如果在应用程序全局都没设置过，那么默认是系统类加载器**。此时通过线程上下文类加载器就可以加载用户自己的代码
3. 双亲委派的第三次被破坏是**由于用户对程序动态性的追求而导致的**，例如热部署、热替换等。例如在OSGi环境下， 类加载器不再是双亲委派模型推荐的树状结构， 而是进一步发展为更加复杂的网状结构  

### 7.5 Java模块化系统

在JDK9中引入了Java模块化系统，其目标是实现**可配置的封装隔离机制**，Java的模块定义包含以下内容

* 依赖其他模块的列表
* 导出的包列表， 即其他模块可以使用的列表
* 开放的包列表， 即其他模块可反射访问模块的列表 
* 使用的服务列表 
* 提供服务的实现列表 

#### 7.5.1 模块的兼容性

**“模块路径”**是相对应于“类路径”的概念，只要是放在类路径上的JAR文件， 无论其中是否包含模块化信息（是否包含了module-info.class文件） ， 它都会被当作传统的JAR包来对待； 相应地， 只要放在模块路径上的JAR文件 ，它都会被当作一个模块来对待  

* **JAR文件在类路径的访问规则**： 所有类路径下的JAR文件及其他资源文件， 都被视为自动打包在一个**匿名模块（Unnamed Module）** 里， 这个匿名模块几乎是没有任何隔离的， 它可以**看到和使用类路径上所有的包、 JDK系统模块中所有的导出包， 以及模块路径上所有模块中导出的包**  
* **模块在模块路径的访问规则**： 模块路径下的**具名模块（Named Module）** **只能访问到它依赖定义中列明依赖的模块和包**， 匿名模块里所有的内容对具名模块来说都是不可见的， 即具名模块看不见传统JAR包的内容  
* **JAR文件在模块路径的访问规则**： 如果把一个传统的、 不包含模块定义的JAR文件放置到模块路径中， 它就会变成一个**自动模块（Automatic Module）** 。 尽管不包含module-info.class， 但**自动模块将默认依赖于整个模块路径中的所有模块， 因此可以访问到所有模块导出的包， 自动模块也默认导出自己所有的包**  

#### 7.5.2 模块化的类加载器

JDK9的类加载架构仍然是三层，同样有双亲委派机制，不过其相对JDK8及之前发生了以下改动

1. **扩展类加载器被平台类加载器取代**
2. **平台类加载器和应用程序类加载器（系统类加载器）不再派生自java.net.URLClassLoader**。现在启动类加载器、平台类加载器和系统类加载器**全部继承于BuiltinClassLoader**

3. **增加了BootClassLoader（启动类加载器），但是在获取时仍然会返回null**

**双亲委派机制的第四次破坏**

当平台及应用程序类加载器收到类加载请求，**在委派给父加载器加载前，要先判断该类是否能够归属到某一个系统模块中**，如果可以找到这样的归属关系，就要优先委派给负责那个模块的加载器完成加载；如果没有找到再委派给父类加载器加载，如果父类无法完成加载，子类加载器才尝试自己加载

## 第8章 虚拟机字节码执行引擎

### 8.1 概述

所有Java虚拟机的执行引擎的输入、输出都是一致的：输入的是二进制流，处理过程是字节码解析执行的等效过程，输出的是执行结果

### 8.2 运行时栈帧结构

Java虚拟机以**方法作为最基本的执行单元**，**栈帧是**支持虚拟机进行方法调用和方法执行背后的**数据结构**

栈帧存储了方法的**局部变量表、操作数栈、动态连接和方法返回地址等信息**，方法从执行到结束对应了一个栈帧从入栈到出栈的过程

栈帧的**局部变量表和操作数栈需要多大的内存在编译期间就已经计算出来**，在运行期间不会改变，在方法的**Code属性中max_locals**确定了局部变量表所需的最大容量；**max_stacks**确定了操作数栈的最大容量

#### 8.2.1 局部变量表

局部变量表是一组变量值的存储空间，用于存储方法参数和方法内部定义的局部变量。Code属性中的max_locals确定了局部变量表所需的最大容量，其在运行期不会改变

局部变量表的容量**以变量槽为单位**，一个变量槽可以存放一个32位以内的数据类型（除了long和double是64位），对于64位的数据使用两个变量槽进行存放

Java虚拟机使用索引的方式使用局部变量表，如果执行的是实例方法，那么第0个变量槽存放的是用于传递方法所属**对象的实例的引用**（通俗点就是this指针）。局部变量表的**变量槽是可以复用的**，方法体中的变量作用域不一定会覆盖整个方法（例如循环中的变量），如果PC计数器超出这个变量的作用域后，其变量槽可以被其他变量重用

#### 8.2.2 操作数栈

操作数栈是一个后入先出的结构，其最大深度也是在**编译期确定**，存放在**Code属性的max_stacks**中。32位数据占用一个栈容量，64位的占用两个栈容量

在概念模型中，不同栈帧的虚拟机栈中的元素是完全相互独立的，但是对于虚拟机实现来说，会优化**使两个栈帧出现一部分重合，令下面的部分操作数栈与上面栈帧的部分局部变量表重合。这样做的目的是可以节约空间，同时在方法调用时能共用一部分数据，避免了参数传递**

![](https://zixianghu-images.oss-cn-chengdu.aliyuncs.com/%E7%AC%94%E8%AE%B0%E6%8F%92%E5%9B%BE/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%A0%88%E5%B8%A7%E4%B9%8B%E9%97%B4%E7%9A%84%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB.png)

#### 8.2.3 动态连接

**每个栈帧包含了一个指向运行时常量池中该栈帧所属方法的引用，目的是为了支持方法调用过程中的动态调用**

在类加载阶段，常量池中的一部分会**在解析阶段将符号引用转换为直接引用**，这种转换称为**静态解析**；另一部分符号引用将**在每一次运行期间转换为直接引用**，这种转换称为**动态连接**

#### 8.2.4 方法返回地址

方法退出的两种方式：遇到返回指令正常方法；在运行过程中遇到了异常，并且异常没有被处理

无论何种返回，在方法退出之后，都必须返回到方法最初被调用的地方，**方法返回时可能需要在栈帧中保存一些信息，用来帮助恢复上层方法的执行状态**

方法退出类似于栈帧出栈，因此可能执行的操作包括：恢复上层方法的局部变量表和操作数栈；将返回结果压入上层方法的栈帧；调整PC计数器使其指向方法调用后的一条指令

### 8.3 方法调用

方法调用不等于方法执行，方法调用的唯一目的是确定被调用方法的版本（调用那个方法）

#### 8.3.1 解析

所有方法在常量池中都有一个符号引用，在类加载的解析阶段，一部分符号引用会被解析为直接引用，**解析成立的前提是被调用的方法在运行期是不可变的**，也就是“编译期已知，运行期不可变”，一**般指私有方法和静态方法两大类**

**Java虚拟机支持的方法调用指令**

1. **invokestatic**

调用静态方法

2. **invokespecial**

调用实例的构造器方法、私有方法和父类中的方法

3. **invokevirtual**

调用所有的虚方法（包括被final修饰的方法，同时被final和static修饰，那么调用指令是invokestatic）

4. **invokeinterface**

调用接口方法，会在**运行时**再确定一个实现该接口的对象

5. **invokeddynamic**

先在**运行时动态解析出调用点限定符所引用的方法**，然后再执行方法。其分派逻辑不一定固化在虚拟机内部，可以由用户指定

只要能被invokestatic、invokespecial调用的方法都可以在解析阶段确定该方法的版本，加上final修饰的方法，**一共5种方法可以在解析阶段确定（静态方法、私有方法、父类方法、实例构造器和final修饰的方法）**。这5种方法被称为**“非虚方法”**，与之对应的就是**“虚方法”**

**总结**

解析调用一定是静态的，在编译期就可以完全确定方法的版本，在类加载阶段就会将符号引用替换成直接引用

与解析调用相对应的是**分派调用**，分派调用可能是静态的也可能是动态的；根据宗数量，可以是多分派也可以是单分派

#### 8.3.2 分派

##### 8.3.2.1 静态分派

**编译期间依据静态类型来决定方法执行版本的分派动作称为静态分派**

```java
Human man = new Man();
Human woman = new Woman();
```

**静态类型（外观类型）**

例如上述代码的"Human",也就是声明时的类型

**实际类型（运行时类型）**

例如上面代码的“Man”和“Woman”，也就是实例时的类型

静态类型和实际类型在程序中都可能发生变换，但是静态类型的变化仅仅在使用时发生，变量本身的静态类型不会被改变；实际类型的变化在运行期才可确定，编译期间并不能确定，例如下面的代码

```java
// 实际类型变化
Human human = (new Random()).nextBoolean() ? new Man() : new Woman();
// 静态类型变化
sr.sayHello((Man) human)
sr.sayHello((Woman) human)
```

**方法重载**

```java
public class StaticDispatch {
    static abstract class Human {
    }

    static class Man extends Human {
    }

    static
    class Woman extends Human {
    }

    public void sayHello(Human guy) {
        System.out.println("hello,guy!");
    }

    public void sayHello(Man guy) {
        System.out.println("hello,gentleman!");
    }

    public void sayHello(Woman guy) {
        System.out.println("hello,lady!");
    }

    public static void main(String[] args) {
        Human man = new Man();
        Human woman = new Woman();
        StaticDispatch sr = new StaticDispatch();
        sr.sayHello(man);
        sr.sayHello(woman);
    }
}
```

>hello,guy!
>hello,guy!

上述代码中的man和woman的静态类型都是Human，但实际类型，但是**编译器在重载方法时是通过参数的静态类型来决定调用那个方法。静态类型在编译期可知，静态分派也是发生在编译阶段**

##### 8.3.2.2 动态分派

**在运行期间根据实际类型进行方法执行版本的分派称为动态分派**

静态分派与方法重载有密切关系；而动态分派则与方法重写有密切关系

**方法重写**

```java
public class DynamicDispatch {
    static abstract class Human {
        protected abstract void sayHello();
    }

    static class Man extends Human {
        @Override
        protected void sayHello() {
            System.out.println("man say hello");
        }
    }

    static class Woman extends Human {
        @Override
        protected void sayHello() {
            System.out.println("woman say hello");
        }
    }

    public static void main(String[] args) {
        Human man = new Man();
        Human woman = new Woman();
        man.sayHello();
        woman.sayHello();
        man = new Woman();
        man.sayHello();
    }
}
```

> man say hello
> woman say hello
> woman say hello

上述代码的man和woman的静态类型都是Human，显然结果不是根据静态类型来决定的，而是根据实际类型决定的，**这种在运行期根据实际类型确定方法执行版本的分派过程称为动态分派**  

这种多态性的**根源在于invokespecial指令**，该指令对字段无效，因此**字段不参与多态的**

那个类的方法访问某个名字的字段时，该名字指的是这个类能看到的那个字段；**当子类与父类的字段重名时，虽然子类内存中两个字段都存在，但是子类字段会遮蔽父类的同名字段**

```java
public class FieldHasNoPolymorphic {
    static class Father {
        public int money = 1;

        public Father() {
            money = 2;
            showMeTheMoney();
        }

        public void showMeTheMoney() {
            System.out.println("I am Father, i have $" + money);
        }
    }

    static class Son extends Father {
        public int money = 3;

        public Son() {
            money = 4;
            showMeTheMoney();
        }

        public void showMeTheMoney() {
            System.out.println("I am Son, i have $" + money);
        }
    }

    public static void main(String[] args) {
        Father gay = new Son();
        System.out.println("This gay has $" + gay.money);
    }
}
```

> I am Son, i have $0 
> I am Son, i have $4
> This gay has $4

**输出0的原因是同名的字段，子类将父类的money屏蔽了，在调用父类构造时，子类的money字段还未被初始化，因此是0**

##### 8.3.2.3 单分派与多分派

**方法的参数和接收者统称为方法的宗量，根据分派基于多少宗量分为多分派和单分派**

如今的Java语言是一门静态多分派、动态单分派的语言

#### 8.3.2.4 虚拟机的动态分派实现

动态分派是执行非常频繁的动作 ，因此， Java虚拟机实现基于执行性能的考虑 ，为了避免在动态分派时频繁搜索所需的类型元数据，一种基础而且常见的优化手段是为类型**在方法区中建立一个虚方法表**（Virtual Method Table， 也称为vtable，与此对应的，在**invokeinterface执行时也会用到接口方法表**——Interface Method Table， 简称itable），使用虚方法表索引来代替元数据查找以提高性能  

**虚方法表中存放着各个方法的实际入口地址**。 如果某个方法在子类中没有被重写，那子类的虚方法表中的地址入口和父类相同方法的地址入口是一致的，都指向父类的实现入口。如果子类中重写了这个方法，子类虚方法表中的地址也会被替换为指向子类实现版本的入口地址

## 第10章 前端编译与优化

### 10.1 概述

**前端编译器**

将`*.java`文件转变成`*.class`文件，例如JDK的Javac

**即使编译器（JIT）**

运行期把字节码编译成本地机器码的过程，例如HotSpot虚拟机中的C1、C2和Graal编译器

**提前编译器（AOT）**

直接把**程序编译成与目标机器指令相关的二进制代码**，例如JDK的Jaotc和GCJ

### 10.3 Java语法糖

#### 10.3.1 泛型

Java的泛型是**类型擦除式泛型**，例如对于`List<String>`和`List<Integer>`对于运行时的Java语言来说都是一样的

```java
public class TypeErasureGenerics<E> {
public void doSomething(Object item) {
        if (item instanceof E) { // 不合法， 无法对泛型进行实例判断
            ...
        }
        E newItem = new E(); // 不合法， 无法使用泛型创建对象
        E[] itemArray = new E[10]; // 不合法， 无法使用泛型创建数组
    }
}
```

#### 10.3.2 自动拆箱、装箱

```java
public static void main(String[] args) {
    Integer a = 1;
    Integer b = 2;
    Integer c = 3;
    Integer d = 3;
    Integer e = 321;
    Integer f = 321;
    Long g = 3L;
    System.out.println(c == d);
    System.out.println(e == f);
    System.out.println(c == (a + b));
    System.out.println(c.equals(a + b));
    System.out.println(g == (a + b));
    System.out.println(g.equals(a + b));
}
```

> true
> false
> true
> true
> true
> false

Integer类内部缓存了[-128,127]的实例，也就是值在[-128,127]之间的Integer实例不管怎么比较都是相等的，源码如下

```java
static final int low = -128;
static final int high;
static final Integer cache[];
cache = new Integer[(high - low) + 1];
int j = low;
for(int k = 0; k < cache.length; k++)
	cache[k] = new Integer(j++);

public static Integer valueOf(int i) {
    if (i >= IntegerCache.low && i <= IntegerCache.high)
        return IntegerCache.cache[i + (-IntegerCache.low)];
    return new Integer(i);
}
```

同时包装类在遇到**算术运算符号**会自动拆箱，==不会自动拆箱，在equls()比较是内部的值是否相等，下面的例子从字节码角度解析自动拆箱和自动装箱

```java
public static void main(String[] args) {
    Integer a = 221;
    Integer b = 200;
    Integer c = 421;
    Integer d = a + b;
    System.out.println(c == d); //false
    System.out.println(c == (a + b)); // true
}
```

局部遍历表如下，由于该方法不是静态方法，因此第0位不是this

| 0    | 1    | 2    | 3    | 4    |
| ---- | ---- | ---- | ---- | ---- |
| args | a    | b    | c    | d    |

字节码如下，可以看到在遇到算术运算符号‘+’时触发了自动拆箱，但是遇到‘==’号是并未触发自动拆箱

```bash
 0 sipush 221 #将常量221压入操作数栈
 3 invokestatic #2 <java/lang/Integer.valueOf>，自动装箱
 6 astore_1 #将实例存入局部变量表索引为1的地方，其实就是把a存到局部变量表索引1的位置
 7 sipush 200 #将常量220压入操作数栈
10 invokestatic #2 <java/lang/Integer.valueOf>，自动装箱
13 astore_2 #将实例存入局部变量表索引为2的地方，其实就是把b存到局部变量表索引2的位置
14 sipush 421 #将常量421压入操作数栈
17 invokestatic #2 <java/lang/Integer.valueOf>，自动装箱
20 astore_3 #将实例存入局部变量表索引为3的地方，其实就是把c存到局部变量表索引3的位置
21 aload_1 #将局部变量表索引为1的实例加载到操作数栈，也就是将a压入操作数栈
22 invokevirtual #3 <java/lang/Integer.intValue> #自动拆箱
25 aload_2 #将局部变量表索引为2的实例加载到操作数栈，也就是将b压入操作数栈
26 invokevirtual #3 <java/lang/Integer.intValue> #自动拆箱
29 iadd #将操作数栈顶的两个元素进行相加，也就是a+b
30 invokestatic #2 <java/lang/Integer.valueOf> #将a+b的结果进行自动装箱
33 astore 4 #将a+b装箱后的结果存入局部变量表索引为4的位置，也就是d
35 getstatic #4 <java/lang/System.out>
38 aload_3 #将局部变量表索引为3的实例加载到操作数栈，也就是将c压入操作数栈
39 aload 4 #将局部变量表索引为4的实例加载到操作数栈，也就是将d压入操作数栈
41 if_acmpne 48 (+7) #注意在比较c和d时并未自动拆箱
44 iconst_1
45 goto 49 (+4)
48 iconst_0
49 invokevirtual #5 <java/io/PrintStream.println>
52 getstatic #4 <java/lang/System.out>
55 aload_3
56 invokevirtual #3 <java/lang/Integer.intValue>
59 aload_1
60 invokevirtual #3 <java/lang/Integer.intValue>
63 aload_2
64 invokevirtual #3 <java/lang/Integer.intValue>
67 iadd
68 if_icmpne 75 (+7)
71 iconst_1
72 goto 76 (+4)
75 iconst_0
76 invokevirtual #5 <java/io/PrintStream.println>
79 return
```

## 第11章 后端编译与优化

### 11.1 概述

字节码只是程序语言的一种中间表示形式，编译器将Class文件转换成本地机器相关的二进制机器码都可以视为编译过程的后端

### 11.2 即时编译器

JIT，将热点代码编译成本地机器码并进行优化

Java程序最初都是通过解释器进行解释执行，当虚拟机发现某个方法或者代码块运行特别频繁，就会把这些代码认为[热点代码](#热点代码)，为了提高热点代码的执行效率，在运行时，虚拟机会将这些代码编译成本地机器码，并进行优化，运行时完成这个任务的后端编译器被称为**即时编译器**

#### 11.2.1 解释器与编译器

HotSpot虚拟机和J9虚拟机内部都同时包含了解释器和编译器。**当程序需要快速启动和执行的时候，解释器可以首先发挥作用，省去编译的时间，立即运行；当程序启动后，编译器逐渐发挥作用，把越来越多的代码编译成本地代码，这样可以减少解释器的中间损耗，获得更高的执行效率**

在JDK10之前HotSpot虚拟机中内置了两个即时编译器，分别叫**客户端编译器（简称C1）和服务端编译器（简称C2）**，在JDK10之后出现了第三个编译器，**Graal编译器**，其长期目标是代替C2编译器

在**分层编译**出现之前，HotSpot虚拟机通常采用解释器与其中一个编译器直接搭配的方式工作；由于即时编译器编译本地代码需要占用程序运行时间，通常JIT对代码优化程度越高，花费时间越长，同时解释器可能还要替编译器收集性能监控信息，这对解释执行的速度也有影响

**分层编译**在JDK6时期被初步实现，其根据编译器编译、优化的规模和耗时划分出不同的编译层次

**实施分层编译之后，解释器可以和C1、C2编译器同时工作，热点代码可能会被多次编译。C1编译获取更高的编译速度，C2编译获取更好的编译质量**

#### 11.2.2 编译对象与触发条件

**<span id="热点代码">热点代码</span>**主要包括两类：多次被调用的方法和多次被执行的循环体

这两种热点代码的编译目标对象都是整个方法体，尽管后者是由循环体触发的，但编译器依然必须以整个方法作为编译对象，只是执行入口并不是方法的第一条指令，这种方式被称为<span id="栈上替换">**栈上替换**</span>

目前主流的热点探测方式有两种

* **基于采样的热点探测**

虚拟机周期性的检查各个线程的调用栈顶，如果发现某个方法经常出现在栈顶，那么这个方法就是热点方法

优点：实现高效简单，很容易获得方法的调用关系

缺点：精度不够，容易受到线程阻塞或别的因素影响热点探测精度

* **基于计数器的热点探测**

虚拟机为每个方法建立计数器，统计方法的执行次数，当执行次数超过一定阈值就判定为热点代码

优点：统计结果更加精确

缺点：实现麻烦，需要维护计数器同时不能直接获取方法的调用关系

HotSpot虚拟机采用计数器的热点探测，HotSpot为每个方法准备了两类计数器：**方法调用计数器和回边计数器**。回边，指在循环边界往回跳转

**方法调用计数器**

![](https://zixianghu-images.oss-cn-chengdu.aliyuncs.com/%E7%AC%94%E8%AE%B0%E6%8F%92%E5%9B%BE/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E8%AE%A1%E6%95%B0%E5%99%A8%E8%A7%A6%E5%8F%91JIT.png)

方法调用时，首先检查是否存在编译过的版本，存在则优先使用编译后的本地代码执行；否在方法调用计数器加一，然后判断该方法的回边计数器和方法调用计数器的和是否超过阈值，一旦超过向编译器提交编译请求

默认情况下，方法调用计数器统计的不是方法被调用的绝对次数，而是一个相对执行频率（即一段时间内的执行次数），**当超过一段时间计数值仍未达到阈值，那么计数值会减少一半**，这个过程称为方法调用计数器的**热度衰减**，而这段时间称为**半衰周期**

**回边计数器**

![](https://zixianghu-images.oss-cn-chengdu.aliyuncs.com/%E7%AC%94%E8%AE%B0%E6%8F%92%E5%9B%BE/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E5%9B%9E%E8%BE%B9%E8%AE%A1%E6%95%B0%E5%99%A8%E8%A7%A6%E5%8F%91JIT.png)



回边计数器是统计一个方法的循环体代码执行的次数，回边计数器的目的是触发[栈上替换](#栈上替换)

当回边计数器和方法调用计数器超过阈值的时候，会提交一个栈上替换编译请求，并把回边计数器的值稍微降低一些，以便继续在解释器中执行循环；同时**回边计数器不会进行热度衰减，因此其计数值是循环体执行的绝对次数，当计数器溢出时，它还会把方法计数器的值也调整到溢出状态，以便下次调用该方法时执行标准的编译过程**

#### 11.2.3 编译过程

默认情况下，无论是方法调用计数器产生的标准编译请求还是回边计数器触发的栈上替换，**虚拟机在编译器还未完成编译之前，都会按照解释方式继续执行代码，编译动作在后台的编译线程中进行**

### 11.3 提前编译器

AOT编译器**在程序运行前把程序代码直接编译成本地机器码**

**优点**：不占用程序运行时间和运算资源；本地机器码保存在磁盘，不占用内存

**缺点**：编译质量不如即时编译；为Java语言的动态性（如反射）带来了额外的复杂性（Java语言的动态性（如反射）在运行时才能确定，而AOT是在程序运行前编译）

### 11.4 编译器优化技术

编译器的难点并不在于能否成功输出机器码，输出代码优化质量的高低才是关键

#### 11.4.2 方法内联

方法内联就是把目标方法的代码原封不动地“复制”到发起调用的方法之中，避免了真实调用的发生，可以为其他优化手段建立基础

只有使用invokestatic、invokespecial指令调用的私有方法、实例构造器、父类方法和静态方法（加上一个final方法，虽然该方法被invokevirtual修饰）才会在编译器进行解析，其他方法都必须在运行时进行方法接收者的选择，也就是**Java语言中默认的实例方法是虚方法**

**虚方法在做内联时很难确定使用那个版本的方法，其实际类型在编译器很难确定，必须运行到这一行代码才能确定**

为了解决虚方法的内联问题，Java虚拟机引入了**类型继承关系分析（CHA）**，用于确定在目前已加载的类中， 某个接口是否有多于一种的实现、 某个类是否存在子类、某个子类是否覆盖了父类的某个虚方法等信息。这样， 编译器在进行内联时就会分不同情况采取不同的处理： 如果是非虚方法，那么直接进行内联就可以了，这种的内联是有百分百安全保障的；如果遇到虚方法，则会向CHA查询此方法在当前程序状态下是否真的有多个目标版本可供选择，如果**查询到只有一个版本**，那就可以假设“应用程序的全貌就是现在运行的这个样子”来进行内联，这种内联被称为**守护内联**

#### 11.4.2 逃逸分析

逃逸分析的基本原理：**分析对象动态作用域**，当一个**对象在方法里面被定义后，它可能被外部方法所引用**（作为调用参数传递到其他方法中），这种称为**方法逃逸**；甚至还有可能**被外部线程访问到**（ 赋值给可以在其他线程中访问的实例变量）， 这种称为**线程逃逸**； 从不逃逸、 方法逃逸到线程逃逸， 依次是从低到高的逃逸

**栈上分配**

如果确定一个对象不会逃逸出线程之外，可以考虑将对象分配到栈上，其所占用的内存随栈帧出栈销毁，减少了GC的压力。栈上分配支持方法逃逸不支持线程逃逸

**标量替换**

标量指JVM中的原始数据类型，Java中的对象称为聚合量，**把聚合量拆为标量的过程称为标量替换**。标量替换可以避免对象的创建，实现也更简单，但是要求对象不能逃逸出方法范围

例子如下

```java
// 原始代码
public int test(int x) {
    int xx = x + 2;
    Point p = new Point(xx, 42);
    return p.getX();
}
// 构造方法内联
public int test(int x) {
    int xx = x + 2;
    Point p = point_memory_alloc(); // 在堆中分配P对象的示意方法
    p.x = xx; // Point构造函数被内联后的样子
    p.y = 42
    return p.x; // Point::getX()被内联后的样子
}
// 标量替换
public int test(int x) {
    int xx = x + 2;
    int px = xx;
    int py = 42
    return px;
}
// 消除无效代码
public int test(int x) {
    return x + 2;
}
```

**同步消除**

如果经过逃逸分析，一个变量不会逃逸出线程，无法被其他线程访问，那么这个变量肯定不会发生竞争，对于这个变量的同步措施就可以放心消除

#### 11.4.3 公共子表达式消除

如果一个表达式E之前已经被计算过了，并且从先前的计算到现在E中所有变量的值都没有发生变化，那么E的这次出现就称为**公共子表达式**。对于这种表达式，没有必要花时间再对它重新进行计算，只需要直接用前面计算过的表达式结果代替E 

**公共子表达式消除发生在后端编译时期（JIT），前端编译不会进行消除（Javac）**

#### 11.4.5 数组边界检查消除

数组边界检查消除优化也是即时编译器的优化技术

在编译期根据数据流分析来确定数组的length值， 并判断引用的下标是否越界， 执行的时候就无须判断进行边界检查；在循环中，使用循环变量来进行数组的访问。 如果编译器只要通过数据流分析就可以判定循环变量的取值范围永远在区间[0， foo.length)之内， 那么在循环中就可以把整个数组的上下界检查消除掉

















































































































